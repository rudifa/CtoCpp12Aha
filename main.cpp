/* generated by Claude.ai upon prompts by @rudifa */

#include <iostream>
#include <vector>
#include <list>
#include <algorithm>
#include <memory>
#include <stdexcept>
#include <string>
#include <fstream>

// 1. References aren't just pointers
void updateValueC(int *x) { *x = 42; }  // C style
void updateValueCpp(int &x) { x = 42; } // C++ style - cleaner, safer

void referenceDemo()
{
    std::cout << "\n1. References Demo:\n";
    int value = 0;
    std::cout << "Before: " << value << std::endl;
    updateValueCpp(value);
    std::cout << "After: " << value << std::endl;
}

// 2. Constructors and destructors (RAII)
class File
{
    std::ofstream fp;

public:
    File(const char *filename) : fp(filename)
    {
        if (!fp)
            throw std::runtime_error("Could not open file");
    }
    void write(const std::string &text)
    {
        fp << text;
    }
    // Destructor automatically closes file
};

void raiiFunctionDemo()
{
    std::cout << "\n2. RAII Demo:\n";
    try
    {
        File f("demo.txt");
        f.write("Hello, RAII!");
        std::cout << "File written successfully\n";
    }
    catch (const std::exception &e)
    {
        std::cout << "Error: " << e.what() << std::endl;
    }
}

// 3. Member functions and 'this'
class Counter
{
    int count = 0;

public:
    void increment() { count++; }
    int get() const { return count; }
};

void memberFunctionDemo()
{
    std::cout << "\n3. Member Functions Demo:\n";
    Counter c;
    c.increment();
    c.increment();
    std::cout << "Counter value: " << c.get() << std::endl;
}

// 4. Operator overloading
class Vector2D
{
    double x, y;

public:
    Vector2D(double x, double y) : x(x), y(y) {}
    Vector2D operator+(const Vector2D &other) const
    {
        return Vector2D(x + other.x, y + other.y);
    }
    void print() const
    {
        std::cout << "(" << x << ", " << y << ")";
    }
};

void operatorOverloadingDemo()
{
    std::cout << "\n4. Operator Overloading Demo:\n";
    Vector2D v1(1, 2), v2(3, 4);
    Vector2D v3 = v1 + v2;
    std::cout << "v1 + v2 = ";
    v3.print();
    std::cout << std::endl;
}

// 5. Templates /* renamed from max to my_max to avoid conflict with std::max */
template <typename T>
T my_max(T a, T b)
{
    return (a > b) ? a : b;
}

void templateDemo()
{
    std::cout << "\n5. Template Demo:\n";
    std::cout << "my_max(42, 73) = " << my_max(42, 73) << std::endl;
    std::cout << "my_max(3.14, 2.718) = " << my_max(3.14, 2.718) << std::endl;
    std::cout << "my_max(\"hello\", \"world\") = " << my_max(std::string("hello"), std::string("world")) << std::endl;
}

// 6. Function overloading
class Shape
{
public:
    void draw(int color)
    {
        std::cout << "Drawing with color " << color << std::endl;
    }
    void draw(int color, bool filled)
    {
        std::cout << "Drawing " << (filled ? "filled" : "outline") << " with color " << color << std::endl;
    }
    void draw(const std::string &pattern)
    {
        std::cout << "Drawing with pattern " << pattern << std::endl;
    }
};

void overloadingDemo()
{
    std::cout << "\n6. Function Overloading Demo:\n";
    Shape s;
    s.draw(42);
    s.draw(42, true);
    s.draw("striped");
}

// 7. STL algorithms
void stlDemo()
{
    std::cout << "\n7. STL Algorithms Demo:\n";
    std::vector<int> vec = {3, 1, 4, 1, 5, 9};
    std::cout << "Before sorting: ";
    for (int n : vec)
        std::cout << n << " ";
    std::cout << std::endl;

    std::sort(vec.begin(), vec.end());

    std::cout << "After sorting: ";
    for (int n : vec)
        std::cout << n << " ";
    std::cout << std::endl;
}

// 8. Inheritance and polymorphism
class Animal
{
public:
    virtual void makeSound() = 0;
    virtual ~Animal() = default;
};

class Dog : public Animal
{
public:
    void makeSound() override { std::cout << "Woof!\n"; }
};

class Cat : public Animal
{
public:
    void makeSound() override { std::cout << "Meow!\n"; }
};

void inheritanceDemo()
{
    std::cout << "\n8. Inheritance Demo:\n";
    std::unique_ptr<Animal> animals[] = {
        std::make_unique<Dog>(),
        std::make_unique<Cat>()};
    for (const auto &animal : animals)
    {
        animal->makeSound();
    }
}

// 9. Exceptions
double divide(double a, double b)
{
    if (b == 0.0)
        throw std::invalid_argument("Division by zero!");
    return a / b;
}

void exceptionDemo()
{
    std::cout << "\n9. Exception Handling Demo:\n";
    try
    {
        std::cout << "10 / 2 = " << divide(10.0, 2.0) << std::endl;
        std::cout << "10 / 0 = " << divide(10.0, 0.0) << std::endl;
    }
    catch (const std::invalid_argument &e)
    {
        std::cout << "Caught exception: " << e.what() << std::endl;
    }
}

// 10. Smart pointers
void smartPtrDemo()
{
    std::cout << "\n10. Smart Pointer Demo:\n";
    {
        auto dog = std::make_unique<Dog>();
        std::cout << "Dog says: ";
        dog->makeSound();
    }
    std::cout << "Dog was automatically deleted\n";
}

// 11. Lambda expressions
void lambdaDemo()
{
    std::cout << "\n11. Lambda Demo:\n";
    std::vector<int> numbers = {1, 2, 3, 4, 5};

    auto isEven = [](int n)
    { return n % 2 == 0; };
    auto evenCount = std::count_if(numbers.begin(), numbers.end(), isEven);

    std::cout << "Numbers: ";
    for (int n : numbers)
        std::cout << n << " ";
    std::cout << "\nCount of even numbers: " << evenCount << std::endl;
}

// 12. Move semantics /* fixed and improved with help from TabNine extension for VS Code */
class BigData
{
    std::vector<double> data;

public:
    BigData(std::vector<double> &&vec) : data(std::move(vec))
    {
        std::cout << "Move constructor called\n";
    }

    // Copy constructor
    BigData(const BigData& other) : data(other.data)
    {
        std::cout << "Copy constructor called\n";
    }

    // Copy assignment operator
    BigData& operator=(const BigData& other)
    {
        std::cout << "Copy assignment called\n";
        if (this != &other)
        {
            data = other.data;
        }
        return *this;
    }

    // Move constructor
    BigData(BigData&& other) noexcept : data(std::move(other.data))
    {
        std::cout << "Move constructor called\n";
    }

    // Move assignment operator
    BigData& operator=(BigData &&other) noexcept
    {
        std::cout << "Move assignment called\n";
        if (this != &other)
        {
            data = std::move(other.data);
        }
        return *this;
    }

    size_t size() const { return data.size(); }
};

void moveDemo()
{
    std::cout << "\n12. Move Semantics Demo:\n";
    std::vector<double> huge_vec(1000000, 3.14);
    std::cout << "Original vector size: " << huge_vec.size() << std::endl;

    BigData bd1(std::move(huge_vec));
    std::cout << "After move, original vector size: " << huge_vec.size() << std::endl;
    std::cout << "New object data size: " << bd1.size() << std::endl;

    BigData bd2 = std::move(bd1);
}

int main()
{
    std::cout << "C++ Aha! Moments Demos\n";
    std::cout << "=====================\n";

    referenceDemo();
    raiiFunctionDemo();
    memberFunctionDemo();
    operatorOverloadingDemo();
    templateDemo();
    overloadingDemo();
    stlDemo();
    inheritanceDemo();
    exceptionDemo();
    smartPtrDemo();
    lambdaDemo();
    moveDemo();

    return 0;
}
